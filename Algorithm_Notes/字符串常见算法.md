# 字符串常见算法  
### 概念  
主串，模式串：在字符串 T 中查找字符串 P，T 就是主串，P 就是模式串，设 T 的长度为 n，P 的长度为 m；
### BF 算法  
#### 概念  
Brute Force 即暴力匹配法，在主串中每次向右移动一个位置，与模式串比较。即能每个字符都相等，则表示在主串中找到模式串；
#### 基本实现和特性  
在主串中，检查起始位置分别是[0,1,2,...,n-m]且长度为 m 的n-m+1个子串，看有没有跟模式串匹配的，时间复杂度为 O(m * n)  
### RK 算法  
#### 概念  
在 BF 中，每次在比较模式串和主串子串匹配的时候，都需要依次比较，RK 则使用哈希算法对上述过程优化  
#### 基本实现和特性  
通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，如果某个子串的哈希值与模式串相等，就说明子串和模式串匹配；  
##### 具体步骤：
1、计算子串的哈希值  
2、模式串哈希值和子串哈希值的比较  
##### 重点：  
1、设计哈希算法，扫描一遍计算 n-m+1子串的哈希值  
2、设计的哈希算法健壮性比较强，可以解决模式串比较长哈希值很大的情况  
3、哈希冲突  
最好的时间复杂度 O（n），最坏时间复杂度O(n * m)  
### BM 算法  
#### 概念  
把主串和模式串的匹配过程看成模式串不停往右移动，当遇到不匹配的字符时，模式串往后滑动一位，然后从模式串的第一位开始匹配，BM 算法借助一些规律将模式串向后多滑动几位；  
#### 基本实现和特性  
算法步骤：  
1、模式字符串的匹配顺序是从右往左：
（1）首先将 P 和 T 对齐，即p[0] 和 t[0] 对齐  
（2）然后匹配从模式字符串 P 的最右端字符开始，即判断 p[m] 和 t[m] 是否匹配；如果匹配成功，则向左移动判断 p[m-1] 和 t[m-1] 是否匹配，如此匹配下去；如果匹配不成功，则进行字符串滑移；
2、字符串滑移启发式策略：
（1）坏字符移动启发式策略
（2）好后缀移动启发式策略
两种策略的使用：如果同时满足两种策略使用条件时，选两者中较大的作为模式串向右滑移的距离  
最坏情况乱下时间复杂度O(n * m)，最好情况下 O(n / m);  
## KMP 算法  
#### 概念  
跟 BM 算法非常近似，在模式串和主串匹配的过程中，当遇到那些不可匹配的字符时，希望有某些规律将模式串往右多滑动几位，跳过那些肯定不会匹配的情况  
#### 基本实现和特性  
######  重难点：
构建模式串 next 数组，用来存储模式串中每个前缀的最长可匹配子串的结尾字符下标；  
时间复制度O(m+n)  
## 多模式串算法  
### Trie 树  
##### 概念  
也称为字典树，是一个树形结构，专门用于处理字符事匹配的数据结构，用来解决在一组字符集合中快速查找某个字符串的问题  
本质是利用字符串之间的公共前缀，将重复的前缀合并在一 起；  
###### 典型应用:
被搜索引擎系统用于文本词频统计；  
###### 基本性质:
1. 根结点不包括字符，除根结点之外每一个结点都只包含一个字符；  
2. 从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串；   
3. 每个结点的所有子结点包含的字符都不相同;  
4. Trie 树是一个多叉树;  
5. Trie 树是多主串匹配算法;  
###### 关键操作：
1. 将字符集构建 Trie 树，时间复杂度 O(n);  
2. 在 Trie 树中查询一个字符串，时间复杂度 O(k)，k 是要查找字符的长度；  
缺点： Trie 树比较消耗内存，典型的空间换时间思想；  
##### 基本实现和特性  
搜索 Trie 树的方法为：
1. 从根结点开始一次搜索  
2. 取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索  
3. 在相应的子树上，取得要查找关键词的第二个字母，并进一步选择对应的子树进行检索  
4. 迭代过程......  
5. 在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找  
### AC 自动机  
#####  概念  
AC自动机就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上；  
##### 基本实现和特性  
重点操作
1. AC自动机的构建：  
 - 将多个模式串建成 Trie 树；  
 - 在 Trie 树上构建失败指针 (类似 KMP 的 next 数组 )；  
2. 在AC自动机上匹配主串；  
## 常考面试题  
1. 回文子串；  
2. 字符串分割子串，子串都是回文串；  
3. 在字典中查找某串；  
4. 实现 Trie 树；  
5. 各种动态规划；  