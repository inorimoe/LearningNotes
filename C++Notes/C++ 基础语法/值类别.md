- [值类别](#值类别)
- [值类别的定义](#值类别的定义)
  - [右值](#右值)
  - [亡值](#亡值)
  - [左值、泛左值、纯右值](#左值泛左值纯右值)

# 值类别
值类别详解：[cppreference::value_category](https://zh.cppreference.com/w/cpp/language/value_category)

基本值类别：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)。
混合值类别：泛左值 (glvalue)、右值 (rvalue)。

* 泛左值表达式包括:
  * 左值
  * 亡值
* 右值表达式包括:
  * 纯右值
  * 亡值

# 值类别的定义

**拥有身份 (identity)**：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址；
**可被移动**：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式。

* **左值 (lvalue)表达式**：拥有身份且不可被移动的表达式；
* **亡值 (xvalue)表达式**：拥有身份且可被移动的表达式；
* **纯右值 (prvalue)表达式**：不拥有身份且可被移动的表达式；（C++17开始，纯右值已不再是可被移动，有了零复制的按值传递语义，见[复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)）
* **泛左值 (glvalue) 表达式**：拥有身份的表达式；左值和亡值都是泛左值表达式。
* **右值 (rvalue) 表达式**：可被移动的表达式；纯右值和亡值都是右值表达式。  

其他：不拥有身份且不可被移动的表达式无法使用。
  
## 右值
右值性质：
* 右值不能由取址运算符取地址。
  ```C++
  &int()、&i++[3]、&42 及 &std::move(x) 是非法的。
  ```
* 右值不能用作赋值运算符及复合赋值运算符的左操作数，也即+=，-=，*=，/=，%=，<<=，>>=，&=，^= 和 |=。
* 右值可以用来初始化 **const 左值引用**，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。
* 右值可以用来初始化**右值引用**，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。
* 当被用作函数实参且该函数有两种重载可用，右值引用优先。
  （即复制与移动构造函数均可用时），以右值实参将调用它的移动构造函数
  1. 右值引用的形参
  2. const 的左值引用的形参的重载函数

## 亡值
性质
* 与右值、泛左值类似。
* 亡值可以绑定到右值引用。
* 亡值可以是多态。
* 非类的亡值可以用 const、volatile（cv）修饰。

下列表达式是亡值表达式：
* a.m，对象成员表达式，其中 a 是右值且 m 是对象类型的非静态数据成员；
* a.*mp，对象的成员指针表达式，其中 a 是右值且 mp 是数据成员指针；
* a, b，内建的逗号表达式，其中 b 是亡值；
* a ? b : c，对某些 b 和 c 的三元条件表达式；
* 返回类型是对象的右值引用的函数调用或重载运算符表达式
  ```std::move(x);```
* a[n]，内建的下标表达式，它的操作数之一是数组右值；
* 转换到对象的右值引用类型的类型转换表达式(C++11 起)，例如 
  ```static_cast<int&&>(x)；```
* 在临时量实质化后，任何指代该临时对象的表达式。(C++17 起)
* 有移动资格的表达式。（C++20起）

## 左值、泛左值、纯右值
左值、泛左值、纯右值不做详解。
三者的定义参考：[值类别的定义](#值类别的定义)
三者的实例参考：[cppreference::value_category](https://zh.cppreference.com/w/cpp/language/value_category)
