# 智能指针
在 C++ 98/03 里使用 new 和 delete 对资源生命周期进行手动管理（构造+释放）。  
在 C++11 引入了智能指针的概念，使用了引用计数的技术。  
这些智能指针包括 ```std::shared_ptr; std::unique_ptr; std::weak_ptr```，使用它们需要包含头文件 ```<memory>```。

## unique_ptr
std::unique_ptr 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象。
std::unique_ptr 的本质是禁用拷贝，仅允许使用移动语义。

### 使用
```c++
std::unique_ptr<int> ptr = std::make_unique<int>(42); 
std::unique_ptr<int> ptr2 = ptr; // 非法，使用拷贝
std::unique_ptr<int> ptr2 = std::move(ptr); // 合法，使用移动语义
```

```C++
struct Foo {...};
...
int main(){
     std::unique_ptr<Foo> p1(std::make_unique<Foo>());

    if (p1) p1->foo(); // p1 不空, 输出
    {
        std::unique_ptr<Foo> p2(std::move(p1));
        
        f(*p2); // p2 不空, 输出
        if(p2) p2->foo(); // p2 不空, 输出
        if(p1) p1->foo(); // p1 为空, 无输出
        
        p1 = std::move(p2);
        if(p2) p2->foo();// p2 为空, 无输出
        std::cout << "p2 离开作用域，被销毁" << std::endl;
    }
    if (p1) p1->foo(); // p1 不空, 输出
}
```
### 注意
std::make_unique 从 C++14 引入.
由于C++ 标准委员会在C++11中忘记提供 std::make_unique. 因其逻辑简单，可以在C++11自行实现：
```c++
template<typename T, typename ...Args>
std::unique_ptr<T> make_unique( Args&& ...args ) {
  return std::unique_ptr<T>( new T( std::forward<Args>(args)... ) );
}
```

## shared_ptr
std::shared_ptr 是一种共享对象的智能指针，它使用引用计数记录多少个 shared_ptr 共同指向一个对象，当引用计数变为零的时候就会将对象自动删除。
### std::make_shared
std::make_shared 会分配创建传入参数中的对象， 并返回这个对象类型的std::shared_ptr指针。

使用 std::make_shared 语法糖，消除显式的使用 new。
使用 0 == shared_ptr<>::use_count（引用计数为零）， 消除显式的调用 delete。
```C++
auto pointer = std::make_shared<int>(42);
```
### 使用
> std::shared_ptr :  
> * 可以通过 get() 方法来获取原始指针。
> * 通过 reset() 来减少一个引用计数。
> * 通过 use_count() 来查看一个对象的引用计数。

```C++
auto pointer = std::make_shared<int>(42);
auto pointer2 = pointer; // 引用计数+1
auto pointer3 = pointer; // 引用计数+1
int *p = pointer.get();  // 这样不会增加引用计数
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl;   // 3
pointer2.reset();
std::cout << "pointer.use_count() = " << pointer.use_count() << std::endl;   // 2
```
## weak_ptr
如果 shared_ptr 的指针指向形成环，std::shared_ptr 存在资源无法释放的问题。（引用计数永不为零，导致资源无法执行析构，内存泄漏）。  
解决这个问题的办法就是使用弱引用指针 std::weak_ptr，（相比较而言 std::shared_ptr 就是一种强引用）弱引用不会引起引用计数增加。  
<b>将weak_ptr引入并替换shared_ptr进行弱引用指向对象资源，破坏shared_ptr指针环的形成条件。</b>
### 使用
>* expired() 方法能在资源未被释放时，会返回 false，否则返回 true。  
>* lock() 方法在原始对象未被释放时，返回一个指向原始对象的 std::shared_ptr 指针。  
>* use_count() 返回管理该对象的 shared_ptr 对象数量。
>* reset() 释放被管理对象的所有权。
>* swap() 交换被管理对象。

具体详见：[cppreference::weak_ptr](https://zh.cppreference.com/w/cpp/memory/weak_ptr)
### 什么是shared_ptr指针环
```C++
struct A;
struct B;

struct A {
    std::shared_ptr<B> pointer;
    ...
};
struct B {
    std::shared_ptr<A> pointer;
    ...
};
int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->pointer = b;
    b->pointer = a;
}
```
运行结果是 A, B 都不会被销毁，这是因为内部的 shared_ptr 互相指向，形成环。
![智能指针A](smartpointer_1.png)
### 如何使用weak_ptr解决内存泄漏
将weak_ptr引入并替换shared_ptr进行弱引用指向对象资源，破坏shared_ptr指针环的形成条件。
```C++
struct A;
struct B;

struct A {
    std::shared_ptr<B> pointer;
    ~A() {
        std::cout << "A 被销毁" << std::endl;
    }
};
struct B {
    std::weak_ptr<A> pointer; // 只修改了这一行，即破环shared_ptr的互相引用。
    ~B() {
        std::cout << "B 被销毁" << std::endl;
    }
};
int main() {
    auto a = std::make_shared<A>();
    auto b = std::make_shared<B>();
    a->pointer = b;
    b->pointer = a;
}
·····················
program returned: 0
Program stdout
A 被销毁
B 被销毁
```
对象 B 的 weak_ptr 只是虚指向 A，没有对 A 对象进行引用计数，破坏了 shared_ptr指针环的形成。如图：
![智能指针B](smartpointer_2.png)