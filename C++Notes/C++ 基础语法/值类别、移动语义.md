# 值类别
值类别详解：[cppreference::value_category](https://zh.cppreference.com/w/cpp/language/value_category)

基本值类别：纯右值 (prvalue)、亡值 (xvalue)、左值 (lvalue)。
混合值类别：泛左值 (glvalue)、右值 (rvalue)

* 泛左值表达式包括:
  * 左值
  * 亡值
* 右值表达式包括:
  * 纯右值
  * 亡值

# 值类别的定义

**拥有身份 (identity)**：可以确定表达式是否与另一表达式指代同一实体，例如通过比较它们所标识的对象或函数的（直接或间接获得的）地址；
**可被移动**：移动构造函数、移动赋值运算符或实现了移动语义的其他函数重载能够绑定于这个表达式。

* **左值 (lvalue)表达式**：拥有身份且不可被移动的表达式；
* **亡值 (xvalue)表达式**：拥有身份且可被移动的表达式；
* **纯右值 (prvalue)表达式**：不拥有身份且可被移动的表达式；（C++17开始，纯右值已不再是可被移动，有了零复制的按值传递语义，见[复制消除](https://zh.cppreference.com/w/cpp/language/copy_elision)）
* **泛左值 (glvalue) 表达式**：拥有身份的表达式；左值和亡值都是泛左值表达式。
* **右值 (rvalue) 表达式**：可被移动的表达式；纯右值和亡值都是右值表达式。
* 不拥有身份且不可被移动的表达式无法使用。
  
## 右值
右值性质：
* 右值不能由取址运算符取地址。
  ```C++
  &int()、&i++[3]、&42 及 &std::move(x) 是非法的。
  ```
* 右值不能用作赋值运算符及复合赋值运算符的左操作数，也即+=，-=，*=，/=，%=，<<=，>>=，&=，^= 和 |=。
* 右值可以用来初始化 **const 左值引用**，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。
* 右值可以用来初始化**右值引用**，这种情况下该右值所标识的对象的生存期被延长到该引用的作用域结尾。
* 当被用作函数实参且该函数有两种重载可用，右值引用优先。
  （即复制与移动构造函数均可用时），以右值实参将调用它的移动构造函数
  1. 右值引用的形参
  2. const 的左值引用的形参的重载函数

## 亡值
性质
* 与右值、泛左值类似。
* 亡值可以绑定到右值引用。
* 亡值可以是多态。
* 非类的亡值可以用 const、volatile（cv）修饰。

下列表达式是亡值表达式：
* a.m，对象成员表达式，其中 a 是右值且 m 是对象类型的非静态数据成员；
* a.*mp，对象的成员指针表达式，其中 a 是右值且 mp 是数据成员指针；
* a, b，内建的逗号表达式，其中 b 是亡值；
* a ? b : c，对某些 b 和 c 的三元条件表达式；
* 返回类型是对象的右值引用的函数调用或重载运算符表达式
  ```std::move(x);```
* a[n]，内建的下标表达式，它的操作数之一是数组右值；
* 转换到对象的右值引用类型的类型转换表达式(C++11 起)，例如 
  ```static_cast<int&&>(x)；```
* 在临时量实质化后，任何指代该临时对象的表达式。(C++17 起)
* 有移动资格的表达式。（C++20起）

## 左值、泛左值、纯右值
左值、泛左值、纯右值不做详解。
三者的定义参考：[值类别的定义](#值类别的定义)
三者的实例参考：[cppreference::value_category](https://zh.cppreference.com/w/cpp/language/value_category)

## 移动语义
移动语义很简单，移动语义使得编译器有可能用廉价的移动操作来代替昂贵的拷贝操作。
正如拷贝构造函数和拷贝赋值操作符给了你控制拷贝语义的权力，移动构造函数和移动赋值操作符也给了你控制移动语义的权力。
移动语义允许创建只可移动（move-only）的类型，例如std::unique_ptr，std::future和std::thread。

### 移动语义快吗？
不一定，比如std::array还有std::string：
```C++
auto a = std::array<int>(0, 10);
auto b = std::move(a);
```
std::array确实支持移动操作。但是使用std::array的移动操作还是复制操作都将花费线性时间的开销，因为每个容器中的元素终归需要拷贝或移动一次，这与“移动一个容器就像操作几个指针一样方便”的含义相去甚远。
```C++
auto s = std::string("test");
auto ms = std::move(s);
```
另一方面，std::string提供了常数时间的移动操作和线性时间的复制操作。这听起来移动比复制快多了，但是可能不一定。许多字符串的实现采用了小字符串优化（small string optimization，SSO）。“小”字符串（比如长度小于15个字符的）存储在了std::string的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不必复制操作更快。
### 移动语义使用原则
《Effective Modern C++ 》
    * 条款二十九：假定移动操作不存在，成本高，未被使用
    * 如果类型已知或者支持移动语义的代码中，就不需要条款二十九的假设。